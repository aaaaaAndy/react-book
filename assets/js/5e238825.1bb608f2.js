"use strict";(self.webpackChunkreact_book=self.webpackChunkreact_book||[]).push([[8207],{3905:(e,n,o)=>{o.d(n,{Zo:()=>p,kt:()=>k});var r=o(7294);function t(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function i(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,r)}return o}function a(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?i(Object(o),!0).forEach((function(n){t(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function s(e,n){if(null==e)return{};var o,r,t=function(e,n){if(null==e)return{};var o,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)o=i[r],n.indexOf(o)>=0||(t[o]=e[o]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)o=i[r],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(t[o]=e[o])}return t}var c=r.createContext({}),l=function(e){var n=r.useContext(c),o=n;return e&&(o="function"==typeof e?e(n):a(a({},n),e)),o},p=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var o=e.components,t=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(o),m=t,k=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return o?r.createElement(k,a(a({ref:n},p),{},{components:o})):r.createElement(k,a({ref:n},p))}));function k(e,n){var o=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=o.length,a=new Array(i);a[0]=m;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[d]="string"==typeof e?e:t,a[1]=s;for(var l=2;l<i;l++)a[l]=o[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,o)}m.displayName="MDXCreateElement"},7244:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=o(7462),t=(o(7294),o(3905));const i={},a=void 0,s={unversionedId:"v16/render/performConcurrentWorkOnRoot",id:"v16/render/performConcurrentWorkOnRoot",title:"performConcurrentWorkOnRoot",description:"performConcurrentWorkOnRoot",source:"@site/docs/v16/render/performConcurrentWorkOnRoot.md",sourceDirName:"v16/render",slug:"/v16/render/performConcurrentWorkOnRoot",permalink:"/react-book/docs/v16/render/performConcurrentWorkOnRoot",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/v16/render/performConcurrentWorkOnRoot.md",tags:[],version:"current",frontMatter:{},sidebar:"v16Sidebar",previous:{title:"ensureRootIsScheduled",permalink:"/react-book/docs/v16/render/ensureRootIsScheduled"},next:{title:"performSyncWorkOnRoot",permalink:"/react-book/docs/v16/render/performSyncWorkOnRoot"}},c={},l=[{value:"<code>performConcurrentWorkOnRoot</code>",id:"performconcurrentworkonroot",level:2},{value:"<code>workLoopConcurrent</code>",id:"workloopconcurrent",level:2},{value:"<code>finishConcurrentRender</code>",id:"finishconcurrentrender",level:2}],p={toc:l},d="wrapper";function u(e){let{components:n,...o}=e;return(0,t.kt)(d,(0,r.Z)({},p,o,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("h2",{id:"performconcurrentworkonroot"},(0,t.kt)("inlineCode",{parentName:"h2"},"performConcurrentWorkOnRoot")),(0,t.kt)("p",null,"\u8be5\u65b9\u6cd5\u4f4d\u4e8e",(0,t.kt)("inlineCode",{parentName:"p"},"react-reconciler/src/ReactFiberWorkLoop.js"),"\u6587\u4ef6\u4e2d\u3002"),(0,t.kt)("p",null,"\u8be5\u65b9\u6cd5\u4e3b\u8981\u5b9e\u73b0",(0,t.kt)("inlineCode",{parentName:"p"},"concurrent"),"\u6a21\u5f0f\u7684\u4efb\u52a1\u8c03\u5ea6\u3002\u5b83\u4e0e",(0,t.kt)("inlineCode",{parentName:"p"},"performSyncWorkOnRoot"),"\u6700\u5927\u7684\u533a\u522b\u6709\u4ee5\u4e0b\u4e24\u5904\uff1a"),(0,t.kt)("ol",null,(0,t.kt)("li",{parentName:"ol"},"\u662f\u5728",(0,t.kt)("inlineCode",{parentName:"li"},"do...while..."),"\u4e2d\u8c03\u7528",(0,t.kt)("inlineCode",{parentName:"li"},"workLoopConcurrent"),"\u65b9\u6cd5\u6765\u5f00\u542f",(0,t.kt)("inlineCode",{parentName:"li"},"render"),"\u9636\u6bb5\uff1b"),(0,t.kt)("li",{parentName:"ol"},(0,t.kt)("inlineCode",{parentName:"li"},"render"),"\u5b8c\u6210\u540e\u8c03\u7528",(0,t.kt)("inlineCode",{parentName:"li"},"finishConcurrentRender"),"\u6765\u8fdb\u5165",(0,t.kt)("inlineCode",{parentName:"li"},"commit"),"\u9636\u6bb5\u3002")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-javascript"},"// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n// \u5f00\u59cb\u8c03\u5ea6concurrent\u4efb\u52a1\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoWork;\n\n  if (didTimeout) {\n    // The render task took too long to complete. Mark the current time as\n    // expired to synchronously render all expired work in a single batch.\n    const currentTime = requestCurrentTimeForUpdate();\n    markRootExpiredAtTime(root, currentTime);\n    // This will schedule a synchronous callback.\n    ensureRootIsScheduled(root);\n    return null;\n  }\n\n  // Determine the next expiration time to work on, using the fields stored\n  // on the root.\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  if (expirationTime !== NoWork) {\n    const originalCallbackNode = root.callbackNode;\n    invariant(\n      (executionContext & (RenderContext | CommitContext)) === NoContext,\n      'Should not already be working.',\n    );\n\n    flushPassiveEffects();\n\n    // If the root or expiration time have changed, throw out the existing stack\n    // and prepare a fresh one. Otherwise we'll continue where we left off.\n    if (\n      root !== workInProgressRoot ||\n      expirationTime !== renderExpirationTime\n    ) {\n      prepareFreshStack(root, expirationTime);\n      startWorkOnPendingInteractions(root, expirationTime);\n    }\n\n    // If we have a work-in-progress fiber, it means there's still work to do\n    // in this root.\n    if (workInProgress !== null) {\n      const prevExecutionContext = executionContext;\n      executionContext |= RenderContext;\n      const prevDispatcher = pushDispatcher(root);\n      const prevInteractions = pushInteractions(root);\n      startWorkLoopTimer(workInProgress);\n      do {\n        try {\n          workLoopConcurrent();\n          break;\n        } catch (thrownValue) {\n          handleError(root, thrownValue);\n        }\n      } while (true);\n      resetContextDependencies();\n      executionContext = prevExecutionContext;\n      popDispatcher(prevDispatcher);\n      if (enableSchedulerTracing) {\n        popInteractions(((prevInteractions: any): Set<Interaction>));\n      }\n\n      if (workInProgressRootExitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        stopInterruptedWorkLoopTimer();\n        prepareFreshStack(root, expirationTime);\n        markRootSuspendedAtTime(root, expirationTime);\n        ensureRootIsScheduled(root);\n        throw fatalError;\n      }\n\n      if (workInProgress !== null) {\n        // There's still work left over. Exit without committing.\n        stopInterruptedWorkLoopTimer();\n      } else {\n        // We now have a consistent tree. The next step is either to commit it,\n        // or, if something suspended, wait to commit it after a timeout.\n        stopFinishedWorkLoopTimer();\n\n        const finishedWork: Fiber = ((root.finishedWork =\n          root.current.alternate): any);\n        root.finishedExpirationTime = expirationTime;\n        finishConcurrentRender(\n          root,\n          finishedWork,\n          workInProgressRootExitStatus,\n          expirationTime,\n        );\n      }\n\n      ensureRootIsScheduled(root);\n      if (root.callbackNode === originalCallbackNode) {\n        // The task node scheduled for this root is the same one that's\n        // currently executed. Need to return a continuation.\n        return performConcurrentWorkOnRoot.bind(null, root);\n      }\n    }\n  }\n  return null;\n}\n")),(0,t.kt)("h2",{id:"workloopconcurrent"},(0,t.kt)("inlineCode",{parentName:"h2"},"workLoopConcurrent")),(0,t.kt)("p",null,"\u8be5\u65b9\u6cd5\u4e0e",(0,t.kt)("inlineCode",{parentName:"p"},"workLoopSync"),"\u65b9\u6cd5\u6700\u5927\u7684\u533a\u522b\u5728\u4e8e\u5b83\u53ef\u4ee5\u4f9d\u9760",(0,t.kt)("inlineCode",{parentName:"p"},"shouldYield"),"\u6765\u63a7\u5236\u4efb\u52a1\u7684\u6267\u884c\uff0c\u662f\u53ef\u4ee5\u4e2d\u65ad\u7684\u3002\u76f8\u540c\u4e4b\u5904\u662f\u5b83\u4eec\u90fd\u9700\u8981\u8c03\u7528",(0,t.kt)("inlineCode",{parentName:"p"},"performUnitOfWork"),"\u6765\u6267\u884c\u4efb\u52a1\u3002"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-javascript"},"/** @noinline */\n/**\n * \u53ef\u4e2d\u65ad\u5730\u5faa\u73af\u8c03\u7528performUnitOfWork\n * \u5b83\u4e0eworkLoopSync\u7684\u533a\u522b\u5c31\u662f\u53ef\u4ee5\u901a\u8fc7shouldYield\u4e2d\u65ad\n */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n")),(0,t.kt)("h2",{id:"finishconcurrentrender"},(0,t.kt)("inlineCode",{parentName:"h2"},"finishConcurrentRender")),(0,t.kt)("p",null,"\u8be5\u65b9\u6cd5\u4f1a\u5bf9",(0,t.kt)("inlineCode",{parentName:"p"},"render"),"\u9636\u6bb5\u7684\u7ed3\u675f\u72b6\u6001\u8fdb\u884c\u4e00\u4e2a\u5224\u65ad\uff0c\u5bf9\u4e0d\u540c\u72b6\u6001\u505a\u4e0d\u540c\u7684\u5904\u7406\uff0c\u6700\u7ec8\u8fd8\u662f\u8c03\u7528",(0,t.kt)("inlineCode",{parentName:"p"},"commitRoot"),"\u8fdb\u5165",(0,t.kt)("inlineCode",{parentName:"p"},"commit"),"\u9636\u6bb5\u3002"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-javascript"},"function finishConcurrentRender(\n  root,\n  finishedWork,\n  exitStatus,\n  expirationTime,\n) {\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  switch (exitStatus) {\n    case RootIncomplete:\n    case RootFatalErrored: {\n      invariant(false, 'Root did not complete. This is a bug in React.');\n    }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n    case RootErrored: {\n      // If this was an async render, the error may have happened due to\n      // a mutation in a concurrent event. Try rendering one more time,\n      // synchronously, to see if the error goes away. If there are\n      // lower priority updates, let's include those, too, in case they\n      // fix the inconsistency. Render at Idle to include all updates.\n      // If it was Idle or Never or some not-yet-invented time, render\n      // at that time.\n      markRootExpiredAtTime(\n        root,\n        expirationTime > Idle ? Idle : expirationTime,\n      );\n      // We assume that this second render pass will be synchronous\n      // and therefore not hit this path again.\n      break;\n    }\n    case RootSuspended: {\n      // code ...\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootSuspendedWithDelay: {\n      // code ...\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      if (\n        // do not delay if we're inside an act() scope\n        !(\n          __DEV__ &&\n          flushSuspenseFallbacksInTests &&\n          IsThisRendererActing.current\n        ) &&\n        workInProgressRootLatestProcessedExpirationTime !== Sync &&\n        workInProgressRootCanSuspendUsingConfig !== null\n      ) {\n        // If we have exceeded the minimum loading delay, which probably\n        // means we have shown a spinner already, we might have to suspend\n        // a bit longer to ensure that the spinner is shown for\n        // enough time.\n        const msUntilTimeout = computeMsUntilSuspenseLoadingDelay(\n          workInProgressRootLatestProcessedExpirationTime,\n          expirationTime,\n          workInProgressRootCanSuspendUsingConfig,\n        );\n        if (msUntilTimeout > 10) {\n          markRootSuspendedAtTime(root, expirationTime);\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      commitRoot(root);\n      break;\n    }\n    default: {\n      invariant(false, 'Unknown root exit status.');\n    }\n  }\n}\n")))}u.isMDXComponent=!0}}]);